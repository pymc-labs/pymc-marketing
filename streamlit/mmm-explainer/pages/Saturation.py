# Import custom functions
import adstock_saturation_functions as asf
import numpy as np
import pandas as pd
import plotly.graph_objects as go

import streamlit as st

# -------------------------- TOP OF PAGE INFORMATION -------------------------

# Set browser / tab config
st.set_page_config(
    page_title="MMM App - Saturation Curves",
    page_icon="ðŸ§Š",
)

# Give some context for what the page displays
st.title("Saturation Curves")
st.markdown(
    "This page demonstrates the forms and shapes of saturation curves for MMM.\
             These curves try to model the relationship between weekly marketing \
            spends for a given channel (holding other channels constant) and \
             the conversions that result from that spend.\
            \n It doesn't need to be conversions, it could be sales or customers acquired\
             - whatever target metric you are interested in.\
            "
)

st.markdown(
    "**Reminder:** \n \
- Certain saturation functions have **_:red[concave or convex shapes]_**  \n\
- Certain saturation functions have **_:red[S-shapes]_**"
)

# -------------------------- SATURATION PLOTS -------------------------

# Generate simulated marketing data
np.random.seed(42)
num_points = 500
media_spending = np.linspace(0, 1000, num_points)  # x-axis
# Scaling factor for nicer plotting


# Generate simulated datasets with noise
dummy_root = asf.root_saturation(media_spending, alpha=0.3) + np.random.normal(
    0, 0.3, num_points
)
dummy_hill = asf.threshold_hill_saturation(
    media_spending, alpha=8, gamma=400, threshold=200
) + np.random.normal(0, 0.05, num_points)
dummy_logistic = asf.logistic_saturation(media_spending, lam=0.01) + np.random.normal(
    0, 0.1, num_points
)
dummy_tanh = asf.tanh_saturation(media_spending, b=10, c=20) + np.random.normal(
    0, 0.75, num_points
)
dummy_m_m = asf.michaelis_menten_saturation(
    media_spending, alpha=20, lam=200
) + np.random.normal(0, 2, num_points)

# Create tabs for Root and Hill plots
tab1, tab2, tab3, tab4, tab5 = st.tabs(
    ["Root", "Hill", "Logistic", "Tanh", "Michaelis-Menten"]
)

# -------------------------- ROOT CURVE -------------------------
with tab1:
    st.subheader(":blue[Root Curve Saturation]")
    st.markdown("___The Root curve takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = x_t^\alpha
        """)
    st.divider()
    # User inputs
    st.subheader(":blue[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Root Curve
    root_alpha = st.slider(
        "**:blue[Root Curve $\\alpha$]:**", 0.0, 1.0, 0.45, key="root_alpha"
    )
    # Calculate the user created response curve
    user_root = asf.root_saturation(media_spending, alpha=root_alpha)

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_root}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_root,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Root Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=500,
        width=1000,
    )

    st.plotly_chart(fig_root, use_container_width=True)

# -------------------------- HILL CURVE -------------------------
with tab2:
    st.subheader(":red[Hill Curve Saturation]")
    st.markdown("___The Hill function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = \frac{x_t^\alpha}{x_t^\alpha + \gamma^\alpha}
        """)
    st.divider()
    # User inputs
    st.subheader(":red[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Hill Curve
    hill_alpha = st.slider(":red[Hill Curve $\\alpha$]:", 0.0, 10.0, 0.45)
    hill_gamma = st.slider(":red[Hill Curve $\\gamma$]:", 1, 1000, 100)
    # Calculate the user created response curve
    user_hill = asf.threshold_hill_saturation(
        media_spending, alpha=hill_alpha, gamma=hill_gamma
    )

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_hill}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_hill,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Hill Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=500,
        width=1000,
    )

    st.plotly_chart(fig_root, use_container_width=True)


# -------------------------- LOGISTIC CURVE -------------------------
with tab3:
    st.subheader(":green[Logistic Curve Saturation]")
    st.markdown("___The Logistic function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = \frac{1 - e^{-\lambda x_t}}{1 + e^{-\lambda x_t}}
        """)
    st.divider()
    # User inputs
    st.subheader(":green[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Modified Logistic Curve
    logistic_lam = st.slider(
        ":green[Logistic Curve $\\lambda$ (scaled value):]",
        0,
        1000,
        500,
        step=1,
        key="logistic_lam",
    )
    logistic_lam = logistic_lam / 10000

    # Calculate the user created response curve
    user_logistic = asf.logistic_saturation(media_spending, lam=logistic_lam)

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_logistic}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_logistic,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Logistic Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=500,
        width=1000,
    )

    st.plotly_chart(fig_root, use_container_width=True)


# -------------------------- TANH CURVE -------------------------
with tab4:
    st.subheader(":orange[Tanh Curve Saturation]")
    st.markdown("___The Tanh saturation function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = b \tanh \left( \frac{x_t}{bc} \right)
        """)
    st.divider()
    # User inputs
    st.subheader(":orange[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Tanh Curve
    tanh_b = st.slider(":orange[Tanh Curve $\\text{b}$]:", 0, 20, 5)
    tanh_c = st.slider(":orange[Tanh Curve $\\text{c}$]:", 0, 100, 50)

    # Calculate the user created response curve
    user_tanh = asf.tanh_saturation(media_spending, b=tanh_b, c=tanh_c)

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_tanh}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_tanh,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Tanh Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=500,
        width=1000,
    )

    st.plotly_chart(fig_root, use_container_width=True)


# -------------------------- MICHAELIS-MENTEN CURVE -------------------------
with tab5:
    st.subheader(":violet[Michaelis-Menten Curve Saturation]")
    st.markdown("___The Michaelis-Menten saturation function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = \frac{\alpha \cdot x_t}{\lambda + x_t}
        """)
    st.divider()
    # User inputs
    st.subheader(":violet[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Tanh Curve
    m_m_alpha = st.slider(":violet[Michaelis-Menten Curve $\\alpha$:]", 0, 50, 25)
    m_m_lambda = st.slider(":violet[Michaelis-Menten Curve $\\lambda$:]", 0, 500, 50)

    # Calculate the user created response curve
    user_m_m = asf.michaelis_menten_saturation(
        media_spending, alpha=m_m_alpha, lam=m_m_lambda
    )

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_m_m}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_m_m,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Michaelis-Menten Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=500,
        width=1000,
    )

    st.plotly_chart(fig_root, use_container_width=True)
