#   Copyright 2022 - 2025 The PyMC Labs Developers
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
"""Streamlit page for saturation curves."""

import numpy as np
import pandas as pd
import plotly.graph_objects as go

import streamlit as st
from pymc_marketing.mmm.transformers import (
    logistic_saturation,
    michaelis_menten,
    tanh_saturation,
)

# Constants
PLOT_HEIGHT = 500
PLOT_WIDTH = 1000

# -------------------------- TOP OF PAGE INFORMATION -------------------------

# Set browser / tab config
st.set_page_config(
    page_title="MMM App - Saturation Curves",
    page_icon="ðŸ§Š",
)

# Give some context for what the page displays
st.title("Saturation Curves")
st.markdown(
    "This page demonstrates the forms and shapes of saturation curves for MMM.\
             These curves try to model the relationship between weekly marketing \
            spends for a given channel (holding other channels constant) and \
             the conversions that result from that spend.\
            \n It doesn't need to be conversions, it could be sales or customers acquired\
             - whatever target metric you are interested in.\
            "
)

st.markdown(
    "**Reminder:** \n \
- Certain saturation functions have **_:red[concave or convex shapes]_**  \n\
- Certain saturation functions have **_:red[S-shapes]_**"
)

# -------------------------- SATURATION PLOTS -------------------------

# Generate simulated marketing data
np.random.seed(42)
num_points = 500
media_spending = np.linspace(0, 1000, num_points)  # x-axis


# Generate simulated datasets with noise
dummy_logistic = logistic_saturation(
    media_spending, lam=0.01
).eval() + np.random.normal(0, 0.1, num_points)
dummy_tanh = tanh_saturation(media_spending, b=10, c=20).eval() + np.random.normal(
    0, 0.75, num_points
)
dummy_m_m = michaelis_menten(media_spending, alpha=20, lam=200) + np.random.normal(
    0, 2, num_points
)

# Create tabs for plots
tab1, tab2, tab3 = st.tabs(["Logistic", "Tanh", "Michaelis-Menten"])

# -------------------------- LOGISTIC CURVE -------------------------
with tab1:
    st.subheader(":green[Logistic Curve Saturation]")
    st.markdown("___The Logistic function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = \frac{1 - e^{-\lambda x_t}}{1 + e^{-\lambda x_t}}
        """)
    st.divider()
    # User inputs
    st.subheader(":green[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Modified Logistic Curve
    logistic_lam = st.slider(
        ":green[Logistic Curve $\\lambda$ (scaled value):]",
        0,
        1000,
        500,
        step=1,
        key="logistic_lam",
    )
    logistic_lam = logistic_lam / 10000

    # Calculate the user created response curve
    user_logistic = logistic_saturation(media_spending, lam=logistic_lam).eval()

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_logistic}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_logistic,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Logistic Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=PLOT_HEIGHT,
        width=PLOT_WIDTH,
    )

    st.plotly_chart(fig_root, use_container_width=True)


# -------------------------- TANH CURVE -------------------------
with tab2:
    st.subheader(":orange[Tanh Curve Saturation]")
    st.markdown("___The Tanh saturation function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = b \tanh \left( \frac{x_t}{bc} \right)
        """)
    st.divider()
    # User inputs
    st.subheader(":orange[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Tanh Curve
    tanh_b = st.slider(":orange[Tanh Curve $\\text{b}$]:", 0, 20, 5)
    tanh_c = st.slider(":orange[Tanh Curve $\\text{c}$]:", 0, 100, 50)

    # Calculate the user created response curve
    user_tanh = tanh_saturation(media_spending, b=tanh_b, c=tanh_c).eval()

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_tanh}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_tanh,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Tanh Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=PLOT_HEIGHT,
        width=PLOT_WIDTH,
    )

    st.plotly_chart(fig_root, use_container_width=True)


# -------------------------- MICHAELIS-MENTEN CURVE -------------------------
with tab3:
    st.subheader(":violet[Michaelis-Menten Curve Saturation]")
    st.markdown("___The Michaelis-Menten saturation function takes the form:___")
    st.latex(r"""
        x_t^{\textrm{transf}} = \frac{\alpha \cdot x_t}{\lambda + x_t}
        """)
    st.divider()
    # User inputs
    st.subheader(":violet[User Inputs]")
    st.markdown("**Try to fit a saturation curve to the generated data!**")

    # User input for Tanh Curve
    m_m_alpha = st.slider(":violet[Michaelis-Menten Curve $\\alpha$:]", 0, 50, 25)
    m_m_lambda = st.slider(":violet[Michaelis-Menten Curve $\\lambda$:]", 0, 500, 50)

    # Calculate the user created response curve
    user_m_m = michaelis_menten(media_spending, alpha=m_m_alpha, lam=m_m_lambda)

    # Tidy the simulated dataset for plotting
    plot_data = pd.DataFrame(
        {"Media Spending": np.round(media_spending), "Conversions": dummy_m_m}
    )
    # Drop rows with negative conversions, generated by the noise
    plot_data = plot_data[plot_data.Conversions >= 0]

    # Plot
    fig_root = go.Figure()
    # Plot weekly spend and response data, every 5th to make the plot less crowded
    fig_root.add_trace(
        go.Scatter(
            x=plot_data["Media Spending"][::5],
            y=plot_data["Conversions"][::5],
            mode="markers",
            name="Weekly Data",
            marker=dict(color="#AB63FA"),
        )
    )
    # Plot user-defined curve to match that data
    fig_root.add_trace(
        go.Scatter(
            x=media_spending,
            y=user_m_m,
            mode="lines",
            name="Saturation Curve",
            line=dict(color="blue", dash="solid"),
        )
    )

    fig_root.update_layout(
        title_text="Michaelis-Menten Saturation Curve",
        xaxis_title="Media Spend",
        yaxis_title="Conversions",
        height=PLOT_HEIGHT,
        width=PLOT_WIDTH,
    )

    st.plotly_chart(fig_root, use_container_width=True)
