---
date: 2026-01-29T20:42:00+00:00
researcher: Claude Sonnet 4.5
git_commit: 72d0ef7a6e90785d66444413bc487e421bfdb2bb
branch: work-issue-2211
repository: pymc-labs/pymc-marketing
topic: "Compute ROAs the correct way (like in the Google paper)"
tags: [research, codebase, roas, adstock, carryover, mmm, budget-optimizer]
status: complete
last_updated: 2026-01-29
last_updated_by: Claude Sonnet 4.5
issue_number: 2211
---

# Research: Compute ROAs the correct way (like in the Google paper)

**Date**: 2026-01-29T20:42:00+00:00
**Researcher**: Claude Sonnet 4.5
**Git Commit**: 72d0ef7a6e90785d66444413bc487e421bfdb2bb
**Branch**: work-issue-2211
**Repository**: pymc-labs/pymc-marketing
**Issue**: #2211

## Research Question

How is ROAS currently computed in the codebase, and what changes are needed to implement formula (10) from the Google MMM paper (https://storage.googleapis.com/gweb-research2023-media/pubtools/3806.pdf) which considers l_max from the adstock effect?

## Summary

The current ROAS implementation is too simplistic: `ROAS[t] = contribution[t] / spend[t]`. This ignores the adstock carryover effect where spend at time `t` contributes to responses in future periods `t, t+1, ..., t+l_max-1`. The correct implementation following formula (10) should sum the contributions across the carryover window. The budget optimizer already correctly handles adstock carryover by padding the optimization horizon with `l_max` additional periods, providing a reference pattern for the fix.

## Problem Statement

### Current Implementation (Incorrect)
```python
ROAS[t] = contribution[t] / spend[t]
```

### Required Implementation (Formula 10)
```python
ROAS[t] = sum(contribution[t:t+l_max]) / spend[t]
```

The issue is that adstock transformations create temporal dependencies via convolution, meaning spend at time `t` affects contributions at times `t, t+1, ..., t+l_max-1`. Therefore, to compute the true return on spend[t], we must sum all contributions generated by that spend across the carryover window.

## Detailed Findings

### 1. Current ROAS Implementation

#### Primary ROAS Computation
**File**: `pymc_marketing/data/idata/mmm_wrapper.py:315-342`

```python
def get_roas(self, original_scale: bool = True) -> xr.DataArray:
    """Compute ROAS (Return on Ad Spend) for each channel.

    ROAS = contribution / spend for each channel.
    """
    contributions = self.get_channel_contributions(original_scale=original_scale)
    spend = self.get_channel_spend()

    # Handle zero spend - use xr.where to avoid division by zero
    spend_safe = xr.where(spend == 0, np.nan, spend)

    return contributions / spend_safe  # Line 342: Simple division
```

**Problems with current implementation:**
- Line 336: Gets `contributions` with dims `(chain, draw, date, channel)`
- Line 337: Gets `spend` with dims `(date, channel)`
- Line 342: Performs element-wise division `contributions[t] / spend[t]`
- **Critical Issue**: Treats each time period independently, ignoring that `spend[t]` creates effects in periods `t` through `t+l_max-1`

#### ROAS Summary Interface
**File**: `pymc_marketing/mmm/summary.py:470-520`

```python
def roas(
    self,
    hdi_probs: Sequence[float] = (0.025, 0.5, 0.975),
    output_format: OutputFormatType = "dataframe",
) -> pd.DataFrame | xr.Dataset:
    """Computes ROAS = contribution / spend"""
    data = self._ensure_data_is_loaded()
    roas = data.get_roas(original_scale=True)  # Line 515: Delegates to wrapper
    df = self._compute_summary_stats_with_hdi(roas, hdi_probs)
    return self._convert_output(df, output_format)
```

This method inherits the same issue from `MMMIDataWrapper.get_roas()`.

### 2. Adstock and Carryover Effects

#### Adstock Base Class
**File**: `pymc_marketing/mmm/components/adstock.py:84-176`

```python
class AdstockTransformation(BaseModel, ABC):
    """Base class for adstock transformations."""

    @validate_call
    def __init__(
        self,
        l_max: int = Field(..., gt=0, description="Maximum lag for the adstock transformation."),
        normalize: bool = Field(True, description="Whether to normalize the adstock values."),
        mode: ConvMode = Field(ConvMode.After, description="Convolution mode."),
        # ...
    ) -> None:
        self.l_max = l_max  # Line 102: Maximum carryover duration
        self.normalize = normalize
        self.mode = mode
```

**Key Parameter**: `l_max` defines the maximum duration of carryover effect.

#### Geometric Adstock Implementation
**File**: `pymc_marketing/mmm/transformers.py:212-297`

```python
def geometric_adstock(
    x,
    alpha: float = 0.0,
    l_max: int = 12,
    normalize: bool = False,
    axis: int = 0,
    mode: ConvMode = ConvMode.After,
) -> TensorVariable:
    """Geometric adstock transformation.

    The cumulative media effect is a weighted average of media spend in the
    current time-period and previous `l_max` - 1 periods. `l_max` is the
    maximum duration of carryover effect.
    """
    # Create weight array: w = [1, α, α², ..., α^(l_max-1)]
    w = pt.power(pt.as_tensor(alpha)[..., None], pt.arange(l_max, dtype=x.dtype))  # Line 295
    w = w / pt.sum(w, axis=-1, keepdims=True) if normalize else w  # Line 296
    return batched_convolution(x, w, axis=axis, mode=mode)  # Line 297
```

**How convolution creates carryover:**
- For `ConvMode.After` (default), the contribution at time `t` is:
  ```
  contribution[t] = w[0]*spend[t] + w[1]*spend[t-1] + ... + w[l_max-1]*spend[t-l_max+1]
  ```
- This means **spend at time `t` affects contributions at times `t, t+1, ..., t+l_max-1`**
- The effect of spend[t] "carries over" into future periods via the adstock weights

#### Other Adstock Types
**File**: `pymc_marketing/mmm/components/adstock.py`

- Line 177-208: `BinomialAdstock`
- Line 210-241: `GeometricAdstock` (most common)
- Line 243-281: `DelayedAdstock` (with peak delay parameter θ)
- Line 284-324: `WeibullPDFAdstock`
- Line 326-366: `WeibullCDFAdstock`

All inherit from `AdstockTransformation` and have the `l_max` parameter.

### 3. Budget Optimizer: Correct Carryover Handling

The budget optimizer **correctly** accounts for adstock carryover, providing a reference implementation pattern.

#### Carryover Padding in Budget Optimizer
**File**: `pymc_marketing/mmm/budget_optimizer.py:896-952`

```python
def _replace_channel_data_by_optimization_variable(self, model: Model) -> Model:
    """Replace `channel_data` in the model graph with optimization variable."""
    num_periods = self.num_periods
    max_lag = self.mmm_model.adstock.l_max  # Line 899: Get l_max from model
    # ...

    # Pad the repeated budgets with zeros to account for carry-over effects
    # We set the repeated budgets in a zero-filled tensor to achieve this
    repeated_budgets_with_carry_over_shape = list(tuple(budgets.shape))
    repeated_budgets_with_carry_over_shape.insert(
        date_dim_idx, num_periods + max_lag  # Line 930: Add l_max extra periods
    )

    repeated_budgets_with_carry_over = pt.zeros(
        repeated_budgets_with_carry_over_shape,
        dtype=channel_data_dtype,
    )
    # Set first num_periods to budget values, rest are zeros
    set_idxs = (*((slice(None),) * date_dim_idx), slice(None, num_periods))
    repeated_budgets_with_carry_over = repeated_budgets_with_carry_over[set_idxs].set(
        pt.cast(repeated_budgets, channel_data_dtype)
    )  # Lines 941-945
```

**Why this is correct:**
- Line 899: Extracts `l_max` from the adstock configuration
- Line 930: Creates a tensor of length `num_periods + max_lag` instead of just `num_periods`
- Lines 941-945: Sets the first `num_periods` entries to the optimization budgets, leaving the remaining `max_lag` periods as zeros
- This allows the adstock convolution to properly compute all carryover effects: spend in the last period `num_periods-1` will have effects extending to period `num_periods-1+l_max-1`

**Comment from @TeemuSailynoja validates this approach:**
> "In the budget optimizer code the response includes adstock carryover."

### 4. Channel Contribution Computation

#### Forward Pass with Adstock
**File**: `pymc_marketing/mmm/mmm.py:611-654`

```python
def _build_channel_contribution(
    self,
    channel_data_scaled: pt.TensorVariable,
    time_index: pt.TensorVariable | None = None,
) -> pt.TensorVariable:
    """Build channel contribution variable."""
    if not self.time_varying_media:
        return pm.Deterministic(
            name="channel_contribution",
            var=self.forward_pass(x=channel_data_scaled),  # Line 633
            dims=("date", "channel"),
        )
```

The `forward_pass` applies transformations in order:

```python
def forward_pass(self, x: pt.TensorVariable | npt.NDArray) -> pt.TensorVariable:
    """Transform channel input into target contributions.

    Handles the ordering of adstock and saturation transformations.
    """
    first, second = (
        (self.adstock, self.saturation)
        if self.adstock_first
        else (self.saturation, self.adstock)
    )

    return second.apply(x=first.apply(x=x, dims="channel"), dims="channel")
```

**Data flow:**
1. `channel_data` (spend) → Adstock transform → Saturation transform → `channel_contribution`
2. The adstock convolution creates the temporal carryover dependencies
3. Each `contribution[t]` is a mixture of effects from multiple spend periods

### 5. Time-Varying Media Effects Considerations

**Comment from @TeemuSailynoja:**
> "One needs to be careful to ensure that the solution works with models including time-varying media effects."

#### Time-Varying Media in MMM
**File**: `pymc_marketing/mmm/mmm.py:630-655`

```python
# Time-varying media implementation
baseline_channel_contribution = self.forward_pass(x=channel_data_scaled)
media_latent_process = create_time_varying_gp_multiplier(
    name="media_latent_process",
    time_index=time_index,
    time_varying_config=self.model_config["media_tvp_config"],
    dims=("date", "channel"),
)
return pm.Deterministic(
    name="channel_contribution",
    var=baseline_channel_contribution * media_latent_process,  # Temporal modulation
    dims=("date", "channel"),
)
```

**Implication for ROAS:**
- Time-varying media effects modulate the baseline contribution with a temporal multiplier
- The ROAS computation must account for this: `contribution[t] = baseline[t] * temporal_multiplier[t]`
- The corrected ROAS formula must still sum over the carryover window even with time-varying effects

#### Time-Varying Implementation Files
**File**: `pymc_marketing/mmm/tvp.py:273-324`

```python
def time_varying_prior(...):
    """Creates time-varying prior using Hilbert Space Gaussian Process (HSGP)."""
```

**File**: `pymc_marketing/mmm/multidimensional.py:1427-1475`

Enhanced time-varying support allowing HSGP objects directly.

### 6. Convolution Modes and Their Impact

**File**: `pymc_marketing/mmm/transformers.py:43-127`

```python
def batched_convolution(
    x: TensorVariable,
    w: TensorVariable,
    axis: int = 0,
    mode: ConvMode = ConvMode.After,
) -> TensorVariable:
    """Core convolution implementation using pt.signal.convolve1d"""
```

**Convolution modes affect carryover direction:**
- `ConvMode.After` (default): Effects trail the spend - spend at `t` affects periods `t` onwards
- `ConvMode.Before`: Effects precede the spend - spend at `t` affects periods before `t`
- `ConvMode.Overlap`: Effects both precede and follow spend

**For ROAS computation:** With `ConvMode.After`, we need to sum `contribution[t:t+l_max]` to capture all effects of `spend[t]`.

## Code References

### Primary Files to Modify
- `pymc_marketing/data/idata/mmm_wrapper.py:315-342` - Main ROAS computation that needs fixing
- `pymc_marketing/mmm/summary.py:470-520` - ROAS summary interface (delegates to wrapper)

### Reference Implementation
- `pymc_marketing/mmm/budget_optimizer.py:899` - Accesses `l_max` from model
- `pymc_marketing/mmm/budget_optimizer.py:926-952` - Correct carryover padding pattern

### Adstock Components
- `pymc_marketing/mmm/components/adstock.py:84-176` - Base adstock class with `l_max`
- `pymc_marketing/mmm/components/adstock.py:210-241` - GeometricAdstock (most common)
- `pymc_marketing/mmm/transformers.py:212-297` - Geometric adstock implementation details
- `pymc_marketing/mmm/transformers.py:43-127` - Batched convolution function

### Model Integration
- `pymc_marketing/mmm/mmm.py:611-654` - Channel contribution building
- `pymc_marketing/mmm/mmm.py:forward_pass` - Applies adstock and saturation transformations

### Time-Varying Support
- `pymc_marketing/mmm/tvp.py:273-324` - Time-varying prior creation
- `pymc_marketing/mmm/mmm.py:630-655` - Time-varying media implementation

### Test Files
- `tests/mmm/test_summary.py:976-980` - `test_division_by_zero_in_roas_handled()`
- `tests/mmm/test_summary.py:380-382` - `test_roas_summary_schema()`

## Architecture Insights

### Temporal Dependencies from Adstock
The adstock transformation creates a many-to-many relationship between spend periods and contribution periods via convolution. This is the root cause of why simple per-period division is incorrect:

1. **Forward effect**: `spend[t]` → affects `contribution[t:t+l_max]`
2. **Backward effect**: `contribution[t]` ← affected by `spend[t-l_max+1:t+1]`

### The Disentanglement Problem
To correctly compute ROAS[t], we need to answer: "What is the total contribution generated by spend[t]?"

**Two possible approaches:**

#### Approach 1: Marginal Contribution (Google Paper Formula 10)
Sum the contributions across the carryover window:
```python
ROAS[t] = sum(contribution[t:min(t+l_max, T)]) / spend[t]
```

**Challenges:**
- Edge effects: Near the end of time series where `t+l_max > T`
- Attribution complexity: `contribution[t+i]` includes effects from multiple spend periods
- Need to determine which portion of `contribution[t+i]` comes from `spend[t]`

#### Approach 2: Decomposed Contribution
Compute the marginal contribution of each spend period to each contribution period using the adstock weights directly:
```python
# For each spend[t], compute its contribution to each future period
marginal_contribution[t, tau] = w[tau-t] * transformed_spend[t] for tau in [t, t+l_max)
ROAS[t] = sum(marginal_contribution[t, :]) / spend[t]
```

This requires accessing or recomputing the adstock weights and applying them correctly.

### Pattern from Budget Optimizer
The budget optimizer demonstrates the correct pattern:
1. Access `l_max` via `self.mmm_model.adstock.l_max`
2. Extend the time dimension by `l_max` periods
3. Pad with zeros to capture trailing effects
4. Let the adstock transformation naturally compute the full carryover

This pattern should inform the ROAS fix implementation.

### Data Structure Considerations
- **Contributions**: `xr.DataArray` with dims `(chain, draw, date, channel)`
- **Spend**: `xr.DataArray` with dims `(date, channel)`
- **ROAS output**: Should maintain dims `(chain, draw, date, channel)` for consistency
- **Edge handling**: Need strategy for periods where `t+l_max > T` (last `l_max-1` periods)

## Implementation Recommendations

### Required Changes

1. **Modify `get_roas()` in `mmm_wrapper.py`:**
   - Access `l_max` from the model's adstock configuration
   - Implement summation over the carryover window `[t, t+l_max)`
   - Handle edge cases for periods near the end of the time series
   - Ensure compatibility with time-varying media effects

2. **Handle ConvMode:**
   - Check the adstock's `mode` parameter
   - For `ConvMode.After`: sum forward `contribution[t:t+l_max]`
   - For `ConvMode.Before`: sum backward `contribution[t-l_max+1:t+1]`
   - For `ConvMode.Overlap`: determine appropriate summation range

3. **Edge Case Handling:**
   - For periods where `t+l_max > T`, sum up to the end: `contribution[t:T]`
   - Consider whether to NaN-out ROAS values for edge periods (last `l_max-1` periods) since they don't capture full carryover
   - Or provide a parameter to control edge behavior

4. **Time-Varying Compatibility:**
   - Ensure the summation works correctly when contributions include time-varying effects
   - The temporal multiplier is already applied to contributions, so summation should work transparently

5. **Zero Spend Handling:**
   - Current `xr.where(spend == 0, np.nan, spend)` pattern should continue to work
   - Apply before division to avoid division by zero

### Formula Implementation Pseudocode

```python
def get_roas(self, original_scale: bool = True) -> xr.DataArray:
    """Compute ROAS with adstock carryover following Google paper formula (10)."""
    contributions = self.get_channel_contributions(original_scale=original_scale)
    spend = self.get_channel_spend()

    # Get l_max from adstock configuration
    l_max = self._get_adstock_l_max()

    # Compute cumulative contribution from each spend period over carryover window
    # ROAS[t] = sum(contribution[t:t+l_max]) / spend[t]
    roas_numerator = self._sum_contributions_over_carryover(contributions, l_max)

    # Handle zero spend
    spend_safe = xr.where(spend == 0, np.nan, spend)

    return roas_numerator / spend_safe
```

### Testing Requirements

1. **Unit tests:**
   - Test ROAS computation with known adstock parameters
   - Verify correct summation over carryover window
   - Test edge cases (beginning and end of time series)
   - Test with zero spend

2. **Integration tests:**
   - Test with different adstock types (Geometric, Delayed, Weibull)
   - Test with time-varying media effects
   - Test with different `ConvMode` settings
   - Verify consistency with budget optimizer's carryover handling

3. **Regression tests:**
   - Update existing ROAS tests in `tests/mmm/test_summary.py`
   - Verify schema remains consistent
   - Test division by zero handling

### Additional Considerations

1. **Documentation updates:**
   - Update docstrings to explain the carryover-aware ROAS formula
   - Reference Google paper formula (10)
   - Explain edge case behavior
   - Add examples to notebooks (e.g., `docs/source/notebooks/mmm/mmm_roas.ipynb`)

2. **Backward compatibility:**
   - Consider providing a parameter to switch between old and new behavior during transition
   - Or accept breaking change if deemed necessary for correctness

3. **Performance:**
   - Summation over carryover window adds computational cost
   - Profile performance impact with large datasets
   - Consider vectorized implementation for efficiency

## Open Questions

1. **Attribution Method**: Should we:
   - Sum contributions across carryover window (simpler, but includes mixed effects)
   - Decompose contributions to isolate marginal effect of each spend period (more accurate, more complex)

2. **Edge Period Handling**: For the last `l_max-1` periods where full carryover extends beyond available data:
   - Set ROAS to NaN (conservative)
   - Compute partial ROAS using available periods (pragmatic)
   - Extrapolate or pad contributions (complex)

3. **ConvMode Support**: Should the implementation:
   - Auto-detect convolution mode and adjust summation direction
   - Assume default `ConvMode.After`
   - Raise error for non-After modes

4. **Time-Varying Effects**: Does the time-varying temporal multiplier affect how we should sum contributions?
   - Current assumption: temporal effects are already baked into contributions, so simple summation works
   - Need to validate this assumption

5. **Multidimensional Models**: Do multidimensional MMMs require special handling?
   - `pymc_marketing/mmm/multidimensional.py` has enhanced time-varying support
   - Need to ensure ROAS computation works correctly with multidimensional channel structure

## Related Research

- Google MMM Paper: https://storage.googleapis.com/gweb-research2023-media/pubtools/3806.pdf (Formula 10)
- Jin et al. (2017): "Bayesian methods for media mix modeling with carryover and shape effects" - Referenced throughout adstock code

## Next Steps

1. **Read the Google Paper**: Carefully review formula (10) and surrounding context to fully understand the intended computation
2. **Design the implementation**: Choose between marginal contribution vs. summation approaches
3. **Prototype the fix**: Implement in `mmm_wrapper.py` with appropriate edge case handling
4. **Add tests**: Write comprehensive unit and integration tests
5. **Validate**: Compare results with budget optimizer to ensure consistency
6. **Document**: Update docstrings, notebooks, and potentially add a guide on interpreting the new ROAS values
7. **Handle time-varying**: Explicitly test and validate with time-varying media effects enabled
